'use client';

import React, { useState, useCallback, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { Textarea } from '@/components/ui/textarea';
import { 
  AlertDialog, 
  AlertDialogAction, 
  AlertDialogCancel, 
  AlertDialogContent, 
  AlertDialogDescription, 
  AlertDialogFooter, 
  AlertDialogHeader, 
  AlertDialogTitle, 
  AlertDialogTrigger 
} from '@/components/ui/alert-dialog';
import { 
  Play, 
  Save, 
  RefreshCw, 
  Download, 
  Upload, 
  Eye, 
  FileText,
  CheckCircle,
  AlertCircle,
  Share2,
  Copy,
  Sparkles,
  Loader2
} from 'lucide-react';
import { useSearchParams } from 'next/navigation';
import { Suspense } from 'react';
import { PanelGroup, Panel, PanelResizeHandle } from 'react-resizable-panels';
import { prdParser } from '@/lib/prd-parser';
import { aiSlideGeneratorV2 } from '@/lib/ai-slide-generator-v2';
import { Presentation } from '@/types/presentation';
import { ClientPresentationViewer } from '@/components/presentation/ClientPresentationViewer';
import { presentationStorage } from '@/lib/presentation-storage';
import { Navigation } from '@/components/layout/Navigation';
import { processURLParameter } from '@/lib/url-utils';
import { cn } from '@/lib/utils';

// ========================================
// DEBUG CONFIGURATION
// ========================================
// Set DEBUG_ENABLED to true to enable comprehensive console debugging throughout the editor
// This will log:
// - AI slide generation process
// - Presentation loading from storage
// - State changes for AI slides
// - Toggle button interactions
// - Slide mode switching
//
// To enable debugging: Change DEBUG_ENABLED to true
// To disable debugging: Change DEBUG_ENABLED to false
const DEBUG_ENABLED = false;

// Helper function to conditionally log debug messages
const debugLog = (...args: any[]) => {
  if (DEBUG_ENABLED) {
    console.log(...args);
  }
};

const debugWarn = (...args: any[]) => {
  if (DEBUG_ENABLED) {
    console.warn(...args);
  }
};

const debugError = (...args: any[]) => {
  if (DEBUG_ENABLED) {
    console.error(...args);
  }
};
// ========================================

const defaultPRD = `---
title: "My AI-Powered Presentation"
author: "Your Name"
tone: "professional"
voice: "engaging"
primary_color: "#00E0FF"
secondary_color: "#FF00AA"
---

# Welcome to PUXA Preso

Transform your **Markdown PRDs** into stunning, interactive presentations with AI assistance.

- Write content in **markdown**
- AI generates styled slides automatically
- Professional transitions and animations
- Fully responsive and shareable

<!-- @slide:generate type="hero" style="dark" transition="fade" -->

---

# Key Features

## What Makes PUXA Special

- **AI-Driven**: OpenAI parses your content and generates optimized slides
- **Markdown Native**: Write in familiar syntax, get beautiful results
- **Responsive Design**: Optimized for all screen sizes and devices
- **Interactive Elements**: ASCII diagrams, code blocks, and rich media

<!-- @slide:generate type="bullet" style="accent" transition="slide" -->

---

# Workflow Transformation

## Before: Manual Slide Creation
\`\`\`
[ Idea ] ‚Üí [ Draft Slides ] ‚Üí [ Design ] ‚Üí [ Review ] ‚Üí [ Present ]
     ‚Üì         ‚Üì              ‚Üì           ‚Üì
   Hours    Manual Work    Inconsistent  Delays
\`\`\`

## After: AI-Powered Generation
\`\`\`
[ PRD Markdown ] ‚Üí [ AI Processing ] ‚Üí [ Beautiful Slides ]
       ‚Üì                 ‚Üì                    ‚Üì
   Minutes         Consistent Style      Ready to Present
\`\`\`

<!-- @slide:generate type="ascii" style="grid" transition="flip" -->

---

# Rich Content Support

## ASCII Diagrams
\`\`\`
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Your Ideas    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Beautiful Slides‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ  ‚Ä¢ Markdown     ‚îÇ    ‚îÇ  ‚Ä¢ Styled HTML  ‚îÇ
‚îÇ  ‚Ä¢ ASCII Art    ‚îÇ    ‚îÇ  ‚Ä¢ Animations   ‚îÇ
‚îÇ  ‚Ä¢ Code Blocks  ‚îÇ    ‚îÇ  ‚Ä¢ Transitions  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

<!-- @slide:generate type="ascii" style="highlight" transition="fade" -->

---

# Getting Started

## Ready to Create?

1. **Edit** your PRD content in the left panel
2. **Watch** the live preview update automatically
3. **Enhance** with AI for professional styling
4. **Present** in fullscreen mode
5. **Share** with your team using short URLs

> *"The best presentations tell a story. PUXA helps you tell yours beautifully."*

<!-- @slide:generate type="summary" style="callout" transition="slide" -->

---

# Next Steps

Start editing this PRD to see the magic happen! ‚ú®

**Pro tip**: Use the slide generation hooks in comments to control how AI styles each section.

<!-- @slide:generate type="summary" style="closing" transition="fade" -->`;

function EditorContent() {
  const searchParams = useSearchParams();
  const [content, setContent] = useState(defaultPRD);
  const [presentation, setPresentation] = useState<Presentation | null>(null);
  const [isValidating, setIsValidating] = useState(false);
  const [validationError, setValidationError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'edit' | 'preview'>('edit');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);


  const [isModifyingPRD, setIsModifyingPRD] = useState(false);
  const [modificationDescription, setModificationDescription] = useState('');
  const [modificationHistory, setModificationHistory] = useState<Array<{description: string, timestamp: Date}>>([]);


  const [hasApiKey, setHasApiKey] = useState(false);
  const [isGeneratingHTML, setIsGeneratingHTML] = useState(false);
  const [aiGeneratedSlides, setAiGeneratedSlides] = useState<any>(null);
  const [useAISlides, setUseAISlides] = useState(false);

  // Parse and validate PRD
  const validateAndParse = useCallback(async (prdContent: string) => {
    setIsValidating(true);
    setValidationError(null);
    
    try {
      const parsed = await prdParser.parseMarkdown(prdContent);
      setPresentation(parsed);
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Invalid PRD format';
      setValidationError(errorMessage);
      setPresentation(null);
      return false;
    } finally {
      setIsValidating(false);
    }
  }, []);

  // Auto-validate on content change (debounced)
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      validateAndParse(content);
    }, 500);

    return () => clearTimeout(timeoutId);
  }, [content, validateAndParse]);

  // Load content from URL parameter or presentation ID
  useEffect(() => {
    const loadFromUrl = async () => {
      const presentationId = searchParams.get('id');
      const urlContent = searchParams.get('content');
      
      // Priority: ID > Content parameter
      if (presentationId) {
        try {
          debugLog('üîÑ Loading presentation from ID:', presentationId);
          const stored = await presentationStorage.getPresentation(presentationId);
          if (stored) {
            debugLog('‚úÖ Loaded presentation:', stored);
            setContent(stored.content);
            setPresentation(stored.presentation);
            
            // Load AI slides if they exist
            if (stored.aiEnhancedPresentation) {
              debugLog('ü§ñ Loading AI slides:', stored.aiEnhancedPresentation);
              setAiGeneratedSlides(stored.aiEnhancedPresentation);
              setUseAISlides(stored.useAISlides || false);
              debugLog('‚úÖ AI slides loaded, useAISlides:', stored.useAISlides);
            }
            
            setHasUnsavedChanges(false); // This is a saved presentation
          } else {
            debugWarn('Presentation not found with ID:', presentationId);
          }
        } catch (error) {
          debugError('Error loading presentation from ID:', error);
        }
      } else if (urlContent) {
        try {
          const decoded = processURLParameter(urlContent);
          
          if (decoded) {
            setContent(decoded);
            setHasUnsavedChanges(true);
          } else {
            debugWarn('Failed to process URL content parameter, using default content');
          }
        } catch (error) {
          debugError('Error loading content from URL:', error);
          // Silently use default content - don't show error to user
        }
      }
    };
    
    loadFromUrl();
  }, [searchParams]);

  // Check for API key
  useEffect(() => {
    const apiKey = process.env.NEXT_PUBLIC_OPENAI_API_KEY;
    console.log('üîë API Key check:');
    console.log('  - API key exists:', !!apiKey);
    console.log('  - API key length:', apiKey?.length || 0);
    console.log('  - API key first 10 chars:', apiKey?.substring(0, 10) || 'none');
    setHasApiKey(!!apiKey);
  }, []);

  // Initial parse
  useEffect(() => {
    validateAndParse(content);
  }, []);

  // Debug AI slides state changes
  useEffect(() => {
    debugLog('üîÑ aiGeneratedSlides state changed:', aiGeneratedSlides);
    if (aiGeneratedSlides) {
      debugLog('üìä AI slides count:', aiGeneratedSlides.htmlSlides?.length || 0);
      debugLog('üîç AI slides structure:', Object.keys(aiGeneratedSlides));
    }
  }, [aiGeneratedSlides]);

  const handleContentChange = (newContent: string) => {
    setContent(newContent);
    setHasUnsavedChanges(true);
  };

  const handleSave = () => {
    // In a real app, this would save to a backend
    localStorage.setItem('prd-draft', content);
    setHasUnsavedChanges(false);
  };

  const handleLoad = () => {
    const saved = localStorage.getItem('prd-draft');
    if (saved) {
      setContent(saved);
      setHasUnsavedChanges(false);
    }
  };

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      const fileContent = await file.text();
      setContent(fileContent);
      setHasUnsavedChanges(true);
    } catch (error) {
      debugError('Error reading file:', error);
    }
  };

  const handleDownload = () => {
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'presentation.md';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const resetToDefault = () => {
    setContent(defaultPRD);
    setHasUnsavedChanges(false);
  };

  const handleShare = async () => {
    if (!presentation) {
      alert('Please wait for the presentation to finish processing before sharing.');
      return;
    }

    try {
      // Save presentation and get short ID
      const presentationId = await presentationStorage.savePresentation(
                    content, 
                    presentation || null, 
                    aiGeneratedSlides, 
                    useAISlides
                  );
      const url = `${window.location.origin}/present?id=${presentationId}`;
      
      await navigator.clipboard.writeText(url);
      alert(`Shareable URL copied to clipboard!\nShort URL: ${url}`);
    } catch (err) {
      debugError('Failed to create shareable URL:', err);
      alert('Failed to create shareable URL. Please try again.');
    }
  };




  const handleAIGenerateHTML = async () => {
    if (!hasApiKey) {
      alert('OpenAI API key not configured. Please add NEXT_PUBLIC_OPENAI_API_KEY to your environment variables.');
      return;
    }

    if (!presentation) {
      alert('Please ensure the PRD is valid before generating AI slides.');
      return;
    }

    setIsGeneratingHTML(true);
    
    try {
      debugLog('üöÄ Starting AI HTML generation...');
      debugLog('üìù Content length:', content.length);
      debugLog('üìù Content preview:', content.substring(0, 200));
      
      const result = await prdParser.parseMarkdownWithAI(content);
      
      debugLog('‚úÖ AI HTML generation result:', result);
      
      if (result.aiEnhanced && result.aiEnhanced.htmlSlides && result.aiEnhanced.htmlSlides.length > 0) {
        debugLog('‚úÖ AI HTML slides generated:', result.aiEnhanced);
        debugLog('üìä Number of slides generated:', result.aiEnhanced.htmlSlides.length);
        debugLog('üîç First slide preview:', result.aiEnhanced.htmlSlides[0]);
        
        // Set state with detailed logging
        debugLog('üîÑ Setting aiGeneratedSlides state...');
        setAiGeneratedSlides(result.aiEnhanced);
        
        debugLog('üîÑ Setting useAISlides to true...');
        setUseAISlides(true);
        
        
        // üöÄ AUTOMATIC SAVE: Persist AI slides immediately
        debugLog('üíæ Auto-saving AI slides...');
        try {
          const presentationId = await presentationStorage.savePresentation(
            content,
            result.presentation,
            result.aiEnhanced,
            true // useAISlides = true
          );
          debugLog('‚úÖ AI slides auto-saved with ID:', presentationId);
          
          // Update URL to include the saved presentation ID
          const newUrl = `${window.location.origin}/editor?id=${presentationId}`;
          window.history.replaceState({}, '', newUrl);
          
          setHasUnsavedChanges(false); // Mark as saved
        } catch (saveError) {
          debugError('‚ö†Ô∏è Auto-save failed:', saveError);
          // Continue anyway - slides are in memory
        }
        
        debugLog('‚úÖ State updates complete');
        alert(`Successfully generated ${result.aiEnhanced.htmlSlides.length} AI-powered HTML slides! View switched to AI slides.`);
      } else {
        throw new Error('No AI-enhanced content was generated');
      }
    } catch (error) {
      debugError('‚ùå AI HTML generation failed:', error);
      alert(`AI HTML generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsGeneratingHTML(false);
    }
  };



  const handlePRDModification = async () => {
    if (!modificationDescription.trim()) {
      alert('Please describe the changes you want to make to the PRD.');
      return;
    }

    if (!hasApiKey) {
      alert('OpenAI API key is required for PRD modification. Please add your API key to the environment variables.');
      return;
    }

    setIsModifyingPRD(true);
    
    try {
      console.log('ü§ñ Modifying PRD with description:', modificationDescription);
      
      // Call AI to modify the PRD
      const modifiedContent = await aiSlideGeneratorV2.modifyPRD(content, modificationDescription);
      
      // Update the content with the modified PRD
      setContent(modifiedContent);
      setHasUnsavedChanges(true);
      
      // üöÄ IMPORTANT: Re-parse the modified PRD to update presentation state
      console.log('üîÑ Re-parsing modified PRD...');
      const parsedResult = await prdParser.parseMarkdown(modifiedContent, false);
      setPresentation(parsedResult);
      
      // Clear any existing AI slides since the PRD changed
      setAiGeneratedSlides(null);
      setUseAISlides(false);
      
      // Add to modification history
      setModificationHistory(prev => [...prev, {
        description: modificationDescription,
        timestamp: new Date()
      }]);
      
      // Clear the modification description
      setModificationDescription('');
      
      alert('PRD successfully modified! The content has been updated with your requested changes. You can now generate new AI slides from the modified PRD.');
      
    } catch (error) {
      console.error('‚ùå PRD modification failed:', error);
      alert(`PRD modification failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsModifyingPRD(false);
    }
  };



  const presentationCount = presentation?.slides.length || 0;

  return (
    <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
      <Navigation />
      <div className="flex-1 flex flex-col">
        {/* PRD Modification Section */}
          <div className="p-4 bg-slate-900/30 border-b border-slate-800">
            <div className="flex items-center gap-2 mb-3">
              <Sparkles className="w-4 h-4 text-purple-400" />
              <h3 className="text-sm font-medium text-purple-400">AI PRD Modification</h3>
            </div>
            
            <div className="flex gap-2">
              <Textarea
                placeholder="Describe the changes you want to make to the PRD (e.g., 'Add a slide about pricing', 'Make the tone more casual', 'Add technical specifications')"
                value={modificationDescription}
                onChange={(e) => setModificationDescription(e.target.value)}
                className="flex-1 min-h-[60px] bg-slate-800 border-slate-700 text-slate-100"
                disabled={isModifyingPRD}
              />
              <Button
                onClick={handlePRDModification}
                disabled={isModifyingPRD || !modificationDescription.trim() || !hasApiKey}
                className="bg-purple-600 hover:bg-purple-700 disabled:bg-slate-700"
              >
                {isModifyingPRD ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Modifying...
                  </>
                ) : (
                  <>
                    <Sparkles className="w-4 h-4 mr-2" />
                    Modify PRD
                  </>
                )}
              </Button>
            </div>
        {/* Modification History */}
            {modificationHistory.length > 0 && (
              <div className="mt-3">
                <h4 className="text-xs font-medium text-slate-400 mb-2">Recent Modifications:</h4>
                <div className="space-y-1 max-h-20 overflow-y-auto">
                  {modificationHistory.slice(-3).map((mod, index) => (
                    <div key={index} className="text-xs text-slate-500 bg-slate-800/50 p-2 rounded">
                      <div className="font-medium">{mod.description}</div>
                      <div className="text-slate-600">{mod.timestamp.toLocaleTimeString()}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

      {/* Top Bar */}
      <div className="flex items-center justify-between p-4 bg-slate-900/50 border-b border-slate-800">
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <FileText className="w-5 h-5 text-blue-400" />
            <h1 className="text-lg font-semibold">PRD Editor</h1>
            {hasUnsavedChanges && (
              <Badge variant="outline" className="text-orange-400 border-orange-400">
                Unsaved
              </Badge>
            )}
          </div>
          

          
          {/* Validation Status */}
          <div className="flex items-center gap-2">
            {isValidating ? (
              <div className="flex items-center gap-2 text-yellow-400">
                <RefreshCw className="w-4 h-4 animate-spin" />
                <span className="text-sm">Validating...</span>
              </div>
            ) : validationError ? (
              <div className="flex items-center gap-2 text-red-400">
                <AlertCircle className="w-4 h-4" />
                <span className="text-sm">Invalid PRD</span>
              </div>
            ) : (
              <div className="flex items-center gap-2 text-green-400">
                <CheckCircle className="w-4 h-4" />
                <span className="text-sm">{presentationCount} slides</span>
              </div>
            )}
            {aiGeneratedSlides && (
              <div className="flex items-center gap-2 text-cyan-400">
                <Sparkles className="w-4 h-4" />
                <span className="text-sm">{aiGeneratedSlides.htmlSlides.length} AI HTML slides</span>
              </div>
            )}
          </div>
          


        </div>

        {/* Actions */}
        <div className="flex items-center gap-2">
          <input
            type="file"
            accept=".md,.markdown"
            onChange={handleFileUpload}
            className="hidden"
            id="file-upload"
          />
          <Button
            variant="ghost"
            size="sm"
            onClick={() => document.getElementById('file-upload')?.click()}
          >
            <Upload className="w-4 h-4 mr-2" />
            Load
          </Button>
          
          <Button variant="ghost" size="sm" onClick={handleSave}>
            <Save className="w-4 h-4 mr-2" />
            Save
          </Button>
          
          <Button variant="ghost" size="sm" onClick={handleDownload}>
            <Download className="w-4 h-4 mr-2" />
            Export
          </Button>

          {presentation && (
            <Button variant="ghost" size="sm" onClick={handleShare}>
              <Share2 className="w-4 h-4 mr-2" />
              Share
            </Button>
          )}

          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button variant="ghost" size="sm">
                <RefreshCw className="w-4 h-4 mr-2" />
                Reset
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Reset to Default</AlertDialogTitle>
                <AlertDialogDescription>
                  This will replace your current content with the default template. 
                  Any unsaved changes will be lost.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={resetToDefault}>
                  Reset
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          {hasApiKey && presentation && (
            <Button 
              size="sm" 
              onClick={handleAIEnhancement}
              disabled={isEnhancing}
              className="bg-purple-600 hover:bg-purple-700"
            >
              {isEnhancing ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Sparkles className="w-4 h-4 mr-2" />
              )}
              {isEnhancing ? 'Enhancing...' : 'AI Enhance (Basic)'}
            </Button>
          )}

          {hasApiKey && (
            <Button
              size="sm"
              onClick={handleAIGenerateHTML}
              disabled={isGeneratingHTML}
              className="bg-gradient-to-r from-cyan-600 to-pink-600 hover:from-cyan-700 hover:to-pink-700 relative"
            >
              {isGeneratingHTML ? (
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              ) : (
                <Sparkles className="w-4 h-4 mr-2" />
              )}
              {isGeneratingHTML ? 'Generating Slides...' : 'AI Generate Slides'}
              {!isGeneratingHTML && (
                <span className="absolute -top-1 -right-1 bg-yellow-400 text-black text-xs px-1 rounded font-bold">
                  NEW
                </span>
              )}
            </Button>
          )}

          {aiGeneratedSlides && (
            <Button 
              size="sm" 
              onClick={async () => {
                if (!presentation) {
                  alert('Please ensure the PRD is valid before presenting.');
                  return;
                }
                try {
                  const presentationId = await presentationStorage.savePresentation(
                    content, 
                    presentation, 
                    aiGeneratedSlides, 
                    useAISlides
                  );
                  setHasUnsavedChanges(false);
                  alert(`AI slides saved! ID: ${presentationId}`);
                } catch (err) {
                  debugError('Failed to save AI slides:', err);
                  alert('Failed to save AI slides. Please try again.');
                }
              }}
              className="bg-green-600 hover:bg-green-700"
            >
              <Save className="w-4 h-4 mr-2" />
              Save AI Slides
            </Button>
          )}

          {presentation && (
            <Button 
              size="sm" 
              className="bg-blue-600 hover:bg-blue-700" 
              onClick={async () => {
                if (!presentation) {
                  alert('Please ensure the PRD is valid before presenting.');
                  return;
                }
                try {
                  const presentationId = await presentationStorage.savePresentation(
                    content, 
                    presentation, 
                    aiGeneratedSlides, 
                    useAISlides
                  );
                  window.open(`/present?id=${presentationId}`, '_blank');
                } catch (err) {
                  debugError('Failed to save presentation:', err);
                  // Fallback to legacy method
                  window.open(`/present?prd=${encodeURIComponent(content)}`, '_blank');
                }
              }}
            >
              <Play className="w-4 h-4 mr-2" />
              Present
            </Button>
          )}
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1">
        <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as any)} className="h-full">
          <TabsList className="grid w-full grid-cols-1 bg-slate-900/50">
            <TabsTrigger value="preview" className="flex items-center gap-2">
              <Eye className="w-4 h-4" />
              Preview
            </TabsTrigger>
          </TabsList>



          <TabsContent value="preview" className="h-[calc(100%-48px)] m-0">
            <PanelGroup direction="horizontal">
              {/* Editor Panel */}
              <Panel defaultSize={50} minSize={30}>
                <div className="h-full flex flex-col bg-slate-900/30 relative z-10">
                  <div className="p-4 border-b border-slate-800">
                    <h3 className="font-medium">Markdown Editor</h3>
                    <p className="text-sm text-slate-200">
                      Edit your PRD content with live validation
                    </p>
                  </div>
                  <div className="flex-1 p-4 relative">
                    <Textarea
                      ref={textareaRef}
                      value={content}
                      onChange={(e) => handleContentChange(e.target.value)}
                      className="w-full h-full resize-none font-mono text-sm bg-slate-950 border-slate-700 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 relative z-20"
                      placeholder="Enter your PRD content..."
                      autoFocus={true}
                      onFocus={(e) => {
                        // Ensure the textarea gets focus and prevents event bubbling
                        e.target.focus();
                        e.stopPropagation();
                      }}
                      onKeyDown={(e) => {
                        // Prevent keyboard events from bubbling to parent elements
                        e.stopPropagation();
                      }}
                    />
                  </div>
                </div>
              </Panel>

              <PanelResizeHandle className="w-2 bg-slate-800 hover:bg-slate-700 transition-colors" />

              {/* Preview Panel */}
              <Panel defaultSize={50} minSize={30}>
                <div className="h-full flex flex-col relative z-0">
                  <div className="p-4 border-b border-slate-800 bg-slate-900/30">
                    <div className="flex items-center justify-between">
                      <div>
                        <h3 className="font-medium">Live Preview</h3>
                        <p className="text-sm text-slate-200">
                          {useAISlides && aiGeneratedSlides ? 'Showing AI-generated slides' : 'See your presentation in real-time'}
                        </p>
                      </div>
                      {aiGeneratedSlides && (
                        <div className="flex items-center gap-1 text-xs">
                          {useAISlides ? (
                            <div className="flex items-center gap-1 text-cyan-400">
                              <Sparkles className="w-3 h-3" />
                              <span>AI Mode</span>
                            </div>
                          ) : (
                            <div className="flex items-center gap-1 text-slate-400">
                              <FileText className="w-3 h-3" />
                              <span>Markdown Mode</span>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                    
                  {/* View Mode Toggle - Now positioned closer to preview */}
                  {aiGeneratedSlides && aiGeneratedSlides.htmlSlides && aiGeneratedSlides.htmlSlides.length > 0 && (
                    <div className="flex items-center justify-center mt-3 pt-3 border-t border-slate-700">
                      <div className="flex items-center gap-3 px-3 py-2 bg-slate-800/50 rounded-lg border border-slate-700">
                        <span className="text-sm font-medium text-slate-200">View Mode:</span>
                        <div className="flex items-center gap-1">
                          <Button
                            variant={useAISlides ? "default" : "outline"}
                            size="sm"
                            onClick={() => {
                              debugLog('üîÑ Switching to AI slides');
                              setUseAISlides(true);
                            }}
                            className={cn(
                              "text-xs transition-all",
                              useAISlides 
                                ? "bg-gradient-to-r from-cyan-600 to-pink-600 hover:from-cyan-700 hover:to-pink-700" 
                                : ""
                            )}
                          >
                            <Sparkles className="w-3 h-3 mr-1" />
                            AI Slides
                          </Button>
                          <Button
                            variant={!useAISlides ? "default" : "outline"}
                            size="sm"
                            onClick={() => {
                              debugLog('üîÑ Switching to Markdown slides');
                              setUseAISlides(false);
                            }}
                            className="text-xs"
                          >
                            <FileText className="w-3 h-3 mr-1" />
                            Markdown
                          </Button>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div className="flex-1 bg-slate-950">
                    {presentation ? (
                      <ClientPresentationViewer 
                        presentation={presentation} 
                        aiEnhancedPresentation={aiGeneratedSlides}
                        useAISlides={useAISlides}
                      />
                    ) : (
                      <div className="h-full flex items-center justify-center">
                        <Card className="bg-slate-900/50 border-slate-700">
                          <CardContent className="p-8 text-center">
                            <AlertCircle className="w-12 h-12 text-yellow-400 mx-auto mb-4" />
                            <h3 className="font-semibold mb-2">No Valid Presentation</h3>
                            <p className="text-sm text-slate-200">
                              Please fix the PRD format to see the preview
                            </p>
                          </CardContent>
                        </Card>
                      </div>
                    )}
                  </div>
                </div>
              </Panel>
            </PanelGroup>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}

export default function EditorPage() {
  return (
    <Suspense fallback={
      <div className="h-[calc(100vh-80px)] flex items-center justify-center">
        <div className="text-center text-slate-100">
          <div className="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p>Loading editor...</p>
        </div>
      </div>
    }>
      <EditorContent />
    </Suspense>
  );
}
